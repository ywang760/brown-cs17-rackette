// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$String = require("bs-platform/lib/js/string.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function charListOfString(str) {
  var helper = function (str, len, k) {
    if (k !== 0) {
      return {
              hd: Caml_string.get(str, len - k | 0),
              tl: helper(str, len, k - 1 | 0)
            };
    } else {
      return /* [] */0;
    }
  };
  return helper(str, str.length, str.length);
}

function getDigit(c) {
  var s = c - /* '0' */48 | 0;
  if (0 <= s && s <= 9) {
    return s;
  }
  
}

function addDigit(digit, number) {
  return Math.imul(number, 10) + digit | 0;
}

function isLegalIdentifierCharacter(ch) {
  if (ch >= 91) {
    if (ch > 122 || ch < 94) {
      return ch >= 126;
    } else {
      return ch !== 96;
    }
  }
  if (ch >= 42) {
    return ch !== 59;
  }
  if (ch < 32) {
    return true;
  }
  switch (ch) {
    case 33 :
    case 35 :
    case 36 :
    case 37 :
    case 38 :
        return true;
    case 32 :
    case 34 :
    case 39 :
    case 40 :
    case 41 :
        return false;
    
  }
}

function readAtom(_chars, _current) {
  while(true) {
    var current = _current;
    var chars = _chars;
    if (!chars) {
      if (current !== undefined) {
        return current;
      } else {
        return Pervasives.failwith("vacuous expression");
      }
    }
    var hd = chars.hd;
    if (hd === 45) {
      var tl = chars.tl;
      if (tl) {
        if (tl.hd !== 45) {
          if (current === undefined) {
            var n = readAtom(tl, undefined);
            switch (n.TAG | 0) {
              case /* NumberC */0 :
                  return {
                          TAG: /* NumberC */0,
                          _0: -n._0 | 0
                        };
              case /* SymbolC */1 :
                  return {
                          TAG: /* SymbolC */1,
                          _0: "-" + n._0
                        };
              case /* ListC */2 :
                  return Pervasives.failwith("EMF");
              
            }
          }
          
        } else if (current === undefined) {
          _current = {
            TAG: /* SymbolC */1,
            _0: "--"
          };
          _chars = tl.tl;
          continue ;
        }
        
      } else {
        if (current === undefined) {
          return {
                  TAG: /* SymbolC */1,
                  _0: "-"
                };
        }
        switch (current.TAG | 0) {
          case /* NumberC */0 :
              return {
                      TAG: /* SymbolC */1,
                      _0: String(current._0) + "-"
                    };
          case /* SymbolC */1 :
              return {
                      TAG: /* SymbolC */1,
                      _0: current._0 + "-"
                    };
          case /* ListC */2 :
              return Pervasives.failwith("EMF");
          
        }
      }
    }
    var tl$1 = chars.tl;
    if (current !== undefined) {
      switch (current.TAG | 0) {
        case /* NumberC */0 :
            var n$1 = current._0;
            var d = getDigit(hd);
            if (d !== undefined) {
              _current = {
                TAG: /* NumberC */0,
                _0: addDigit(d, n$1)
              };
              _chars = tl$1;
              continue ;
            }
            _current = {
              TAG: /* SymbolC */1,
              _0: String(n$1) + $$String.make(1, hd)
            };
            _chars = tl$1;
            continue ;
        case /* SymbolC */1 :
            if (!isLegalIdentifierCharacter(hd)) {
              return Pervasives.failwith("invalid character identifier");
            }
            _current = {
              TAG: /* SymbolC */1,
              _0: current._0 + $$String.make(1, hd)
            };
            _chars = tl$1;
            continue ;
        case /* ListC */2 :
            return Pervasives.failwith("readAtom only handles atomic expressions");
        
      }
    } else {
      var d$1 = getDigit(hd);
      if (d$1 !== undefined) {
        _current = {
          TAG: /* NumberC */0,
          _0: d$1
        };
        _chars = tl$1;
        continue ;
      }
      if (!isLegalIdentifierCharacter(hd)) {
        return Pervasives.failwith("invalid character identifier");
      }
      _current = {
        TAG: /* SymbolC */1,
        _0: $$String.make(1, hd)
      };
      _chars = tl$1;
      continue ;
    }
  };
}

function trimWhitespace(input) {
  var trimLeadingWhitespace = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var hd = param.hd;
      if (hd >= 11) {
        if (hd !== 32) {
          return {
                  hd: hd,
                  tl: param.tl
                };
        }
        _param = param.tl;
        continue ;
      }
      if (hd < 9) {
        return {
                hd: hd,
                tl: param.tl
              };
      }
      _param = param.tl;
      continue ;
    };
  };
  return List.rev(trimLeadingWhitespace(List.rev(trimLeadingWhitespace(input))));
}

function untilWhitespace(chars) {
  if (!chars) {
    return [
            /* [] */0,
            /* [] */0
          ];
  }
  var hd = chars.hd;
  if (hd > 32 || hd < 9) {
    if (hd === 41 || hd === 40) {
      return [
              /* [] */0,
              chars
            ];
    }
    
  } else if (hd > 31 || hd < 11) {
    return [
            /* [] */0,
            chars.tl
          ];
  }
  var match = untilWhitespace(chars.tl);
  return [
          {
            hd: hd,
            tl: match[0]
          },
          match[1]
        ];
}

function treeOfExpression(chars) {
  var trimmedChars = trimWhitespace(chars);
  if (!trimmedChars) {
    return [
            {
              TAG: /* Terminal */0,
              _0: /* [] */0
            },
            /* [] */0
          ];
  }
  if (trimmedChars.hd !== 40) {
    var match = untilWhitespace(trimmedChars);
    return [
            {
              TAG: /* Terminal */0,
              _0: match[0]
            },
            match[1]
          ];
  }
  var match$1 = makeTreeList(trimmedChars.tl);
  return [
          {
            TAG: /* Expression */1,
            _0: match$1[0]
          },
          match$1[1]
        ];
}

function makeTreeList(chars) {
  var trimmedChars = trimWhitespace(chars);
  if (!trimmedChars) {
    return Pervasives.failwith("wrong number of parentheses");
  }
  if (trimmedChars.hd === 41) {
    return [
            /* [] */0,
            trimmedChars.tl
          ];
  }
  var match = treeOfExpression(chars);
  var match$1 = makeTreeList(match[1]);
  return [
          {
            hd: match[0],
            tl: match$1[0]
          },
          match$1[1]
        ];
}

function readHelper(expression) {
  var readTree = function (tree) {
    if (tree.TAG === /* Terminal */0) {
      return readAtom(tree._0, undefined);
    } else {
      return {
              TAG: /* ListC */2,
              _0: List.map(readTree, tree._0)
            };
    }
  };
  var match = treeOfExpression(expression);
  return [
          readTree(match[0]),
          match[1]
        ];
}

function read(input) {
  return readHelper(charListOfString(input))[0];
}

function readAll(input) {
  var readAllHelper = function (lst) {
    if (!lst) {
      return /* [] */0;
    }
    var match = readHelper(lst);
    return {
            hd: match[0],
            tl: readAllHelper(match[1])
          };
  };
  return readAllHelper(charListOfString(input));
}

var Reader = {
  read: read,
  readAll: readAll
};

exports.Reader = Reader;
/* No side effect */
