// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Read$Rackette = require("./Read.bs.js");
var CS17SetupRackette$Rackette = require("./CS17SetupRackette.bs.js");

function plus(va) {
  if (!va) {
    return Pervasives.failwith("+ expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith("+ expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("+ expects 2 arguments");
      } else {
        return {
                TAG: /* NumV */0,
                _0: int1._0 + int2._0 | 0
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for +");
  } else {
    return Pervasives.failwith("+ expects 2 arguments");
  }
}

function minus(va) {
  if (!va) {
    return Pervasives.failwith("- expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith("- expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("- expects 2 arguments");
      } else {
        return {
                TAG: /* NumV */0,
                _0: int1._0 - int2._0 | 0
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for -");
  } else {
    return Pervasives.failwith("- expects 2 arguments");
  }
}

function multiply(va) {
  if (!va) {
    return Pervasives.failwith("* expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith("* expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("* expects 2 arguments");
      } else {
        return {
                TAG: /* NumV */0,
                _0: Math.imul(int1._0, int2._0)
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for *");
  } else {
    return Pervasives.failwith("* expects 2 arguments");
  }
}

function divide(va) {
  if (!va) {
    return Pervasives.failwith("/ expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith("/ expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("/ expects 2 arguments");
      } else {
        return {
                TAG: /* NumV */0,
                _0: Caml_int32.div(int1._0, int2._0)
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for /");
  } else {
    return Pervasives.failwith("/ expects 2 arguments");
  }
}

function rem(va) {
  if (!va) {
    return Pervasives.failwith("remainder expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith("remainder expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("remainder expects 2 arguments");
      } else {
        return {
                TAG: /* NumV */0,
                _0: Caml_int32.mod_(int1._0, int2._0)
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for remainder");
  } else {
    return Pervasives.failwith("remainder expects 2 arguments");
  }
}

function equalInt(va) {
  if (!va) {
    return Pervasives.failwith("= expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith("= expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("= expects 2 arguments");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: int1._0 === int2._0
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for =");
  } else {
    return Pervasives.failwith("= expects 2 arguments");
  }
}

function lssThn(va) {
  if (!va) {
    return Pervasives.failwith("< expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith("< expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("< expects 2 arguments");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: int1._0 < int2._0
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for <");
  } else {
    return Pervasives.failwith("< expects 2 arguments");
  }
}

function grtrThn(va) {
  if (!va) {
    return Pervasives.failwith("> expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith("> expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("> expects 2 arguments");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: int1._0 > int2._0
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for >");
  } else {
    return Pervasives.failwith("> expects 2 arguments");
  }
}

function lessOrEqual(va) {
  if (!va) {
    return Pervasives.failwith("<= expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith("<= expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("<= expects 2 arguments");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: int1._0 <= int2._0
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for <=");
  } else {
    return Pervasives.failwith("<= expects 2 arguments");
  }
}

function greaterOrEqual(va) {
  if (!va) {
    return Pervasives.failwith(">= expects 2 arguments");
  }
  var int1 = va.hd;
  if (int1.TAG === /* NumV */0) {
    var match = va.tl;
    if (!match) {
      return Pervasives.failwith(">= expects 2 arguments");
    }
    var int2 = match.hd;
    if (int2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith(">= expects 2 arguments");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: int1._0 >= int2._0
              };
      }
    }
    
  }
  var match$1 = va.tl;
  if (match$1 && !match$1.tl) {
    return Pervasives.failwith("Wrong value type for >=");
  } else {
    return Pervasives.failwith(">= expects 2 arguments");
  }
}

function equalP(va) {
  if (!va) {
    return Pervasives.failwith("equal? expects 2 arguments");
  }
  var int1 = va.hd;
  switch (int1.TAG | 0) {
    case /* NumV */0 :
        var match = va.tl;
        if (!match) {
          return Pervasives.failwith("equal? expects 2 arguments");
        }
        var int2 = match.hd;
        if (int2.TAG === /* NumV */0) {
          if (match.tl) {
            return Pervasives.failwith("equal? expects 2 arguments");
          } else {
            return {
                    TAG: /* BoolV */1,
                    _0: int1._0 === int2._0
                  };
          }
        }
        break;
    case /* BoolV */1 :
        var match$1 = va.tl;
        if (!match$1) {
          return Pervasives.failwith("equal? expects 2 arguments");
        }
        var bool2 = match$1.hd;
        if (bool2.TAG === /* BoolV */1) {
          if (match$1.tl) {
            return Pervasives.failwith("equal? expects 2 arguments");
          } else {
            return {
                    TAG: /* BoolV */1,
                    _0: int1._0 === bool2._0
                  };
          }
        }
        break;
    case /* ListV */2 :
        var match$2 = va.tl;
        if (!match$2) {
          return Pervasives.failwith("equal? expects 2 arguments");
        }
        var list2 = match$2.hd;
        if (list2.TAG === /* ListV */2) {
          if (match$2.tl) {
            return Pervasives.failwith("equal? expects 2 arguments");
          } else {
            return {
                    TAG: /* BoolV */1,
                    _0: Caml_obj.caml_equal(int1._0, list2._0)
                  };
          }
        }
        break;
    case /* BuiltinV */3 :
    case /* ClosureV */4 :
        break;
    
  }
  var match$3 = va.tl;
  if (match$3 && !match$3.tl) {
    return {
            TAG: /* BoolV */1,
            _0: false
          };
  } else {
    return Pervasives.failwith("equal? expects 2 arguments");
  }
}

function nmbrP(va) {
  if (va) {
    if (va.hd.TAG === /* NumV */0) {
      if (va.tl) {
        return Pervasives.failwith("number? expects 1 argument");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (va.tl) {
      return Pervasives.failwith("number? expects 1 argument");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("number? expects 1 argument");
  }
}

function zeroP(va) {
  if (!va) {
    return Pervasives.failwith("zero? expects 1 argument");
  }
  var $$int = va.hd;
  if ($$int.TAG === /* NumV */0) {
    if (va.tl) {
      return Pervasives.failwith("zero? expects 1 argument");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: $$int._0 === 0
            };
    }
  } else if (va.tl) {
    return Pervasives.failwith("zero? expects 1 argument");
  } else {
    return Pervasives.failwith("zero? expects a number");
  }
}

function cons(va) {
  if (!va) {
    return Pervasives.failwith("cons expects 2 arguments");
  }
  var match = va.tl;
  if (!match) {
    return Pervasives.failwith("cons expects 2 arguments");
  }
  var items = match.hd;
  if (items.TAG === /* ListV */2) {
    if (match.tl) {
      return Pervasives.failwith("cons expects 2 arguments");
    } else {
      return {
              TAG: /* ListV */2,
              _0: {
                hd: va.hd,
                tl: items._0
              }
            };
    }
  } else if (match.tl) {
    return Pervasives.failwith("cons expects 2 arguments");
  } else {
    return Pervasives.failwith("Wrong value type for cons");
  }
}

function first(va) {
  if (!va) {
    return Pervasives.failwith("first expects 1 argument");
  }
  var match = va.hd;
  if (match.TAG !== /* ListV */2) {
    if (va.tl) {
      return Pervasives.failwith("first expects 1 argument");
    } else {
      return Pervasives.failwith("Wrong value type for first");
    }
  }
  var match$1 = match._0;
  if (match$1) {
    if (va.tl) {
      return Pervasives.failwith("first expects 1 argument");
    } else {
      return match$1.hd;
    }
  } else if (va.tl) {
    return Pervasives.failwith("first expects 1 argument");
  } else {
    return Pervasives.failwith("first expects a non-empty list");
  }
}

function rest(va) {
  if (!va) {
    return Pervasives.failwith("rest expects 1 argument");
  }
  var match = va.hd;
  if (match.TAG !== /* ListV */2) {
    if (va.tl) {
      return Pervasives.failwith("rest expects 1 argument");
    } else {
      return Pervasives.failwith("Wrong value type for rest");
    }
  }
  var match$1 = match._0;
  if (match$1) {
    if (va.tl) {
      return Pervasives.failwith("rest expects 1 argument");
    } else {
      return {
              TAG: /* ListV */2,
              _0: match$1.tl
            };
    }
  } else if (va.tl) {
    return Pervasives.failwith("rest expects 1 argument");
  } else {
    return Pervasives.failwith("rest expects a non-empty list");
  }
}

function emptyP(va) {
  if (!va) {
    return Pervasives.failwith("empty? expects 1 argument");
  }
  var match = va.hd;
  if (match.TAG === /* ListV */2) {
    if (match._0) {
      if (va.tl) {
        return Pervasives.failwith("empty? expects 1 argument");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: false
              };
      }
    } else if (va.tl) {
      return Pervasives.failwith("empty? expects 1 argument");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  } else if (va.tl) {
    return Pervasives.failwith("empty? expects 1 argument");
  } else {
    return {
            TAG: /* BoolV */1,
            _0: false
          };
  }
}

function consP(va) {
  if (!va) {
    return Pervasives.failwith("cons? expects 1 argument");
  }
  var match = va.hd;
  if (match.TAG === /* ListV */2) {
    if (match._0) {
      if (va.tl) {
        return Pervasives.failwith("cons? expects 1 argument");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (va.tl) {
      return Pervasives.failwith("cons? expects 1 argument");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else if (va.tl) {
    return Pervasives.failwith("cons? expects 1 argument");
  } else {
    return {
            TAG: /* BoolV */1,
            _0: false
          };
  }
}

function not_(va) {
  if (!va) {
    return Pervasives.failwith("not expects 1 argument");
  }
  var bool = va.hd;
  if (bool.TAG === /* BoolV */1) {
    if (va.tl) {
      return Pervasives.failwith("not expects 1 argument");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: !bool._0
            };
    }
  } else if (va.tl) {
    return Pervasives.failwith("not expects 1 argument");
  } else {
    return Pervasives.failwith("Wrong value type for not");
  }
}

function list(va) {
  return {
          TAG: /* ListV */2,
          _0: va
        };
}

var initialTle_0 = [
  /* Name */{
    _0: "+"
  },
  {
    TAG: /* BuiltinV */3,
    _0: {
      bName: "<builtin: + >",
      bProc: plus
    }
  }
];

var initialTle_1 = {
  hd: [
    /* Name */{
      _0: "-"
    },
    {
      TAG: /* BuiltinV */3,
      _0: {
        bName: "<builtin: - >",
        bProc: minus
      }
    }
  ],
  tl: {
    hd: [
      /* Name */{
        _0: "*"
      },
      {
        TAG: /* BuiltinV */3,
        _0: {
          bName: "<builtin: * >",
          bProc: multiply
        }
      }
    ],
    tl: {
      hd: [
        /* Name */{
          _0: "/"
        },
        {
          TAG: /* BuiltinV */3,
          _0: {
            bName: "<builtin: / >",
            bProc: divide
          }
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "remainder"
          },
          {
            TAG: /* BuiltinV */3,
            _0: {
              bName: "<builtin: Remainder>",
              bProc: rem
            }
          }
        ],
        tl: {
          hd: [
            /* Name */{
              _0: "="
            },
            {
              TAG: /* BuiltinV */3,
              _0: {
                bName: "<builtin: = >",
                bProc: equalInt
              }
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "<"
              },
              {
                TAG: /* BuiltinV */3,
                _0: {
                  bName: "<builtin: < >",
                  bProc: lssThn
                }
              }
            ],
            tl: {
              hd: [
                /* Name */{
                  _0: ">"
                },
                {
                  TAG: /* BuiltinV */3,
                  _0: {
                    bName: "<builtin: > >",
                    bProc: grtrThn
                  }
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "<="
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      bName: "<builtin: <= >",
                      bProc: lessOrEqual
                    }
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: ">="
                    },
                    {
                      TAG: /* BuiltinV */3,
                      _0: {
                        bName: "<builtin: >= >",
                        bProc: greaterOrEqual
                      }
                    }
                  ],
                  tl: {
                    hd: [
                      /* Name */{
                        _0: "equal?"
                      },
                      {
                        TAG: /* BuiltinV */3,
                        _0: {
                          bName: "<builtin: equal?>",
                          bProc: equalP
                        }
                      }
                    ],
                    tl: {
                      hd: [
                        /* Name */{
                          _0: "number?"
                        },
                        {
                          TAG: /* BuiltinV */3,
                          _0: {
                            bName: "<builtin: number?>",
                            bProc: nmbrP
                          }
                        }
                      ],
                      tl: {
                        hd: [
                          /* Name */{
                            _0: "zero?"
                          },
                          {
                            TAG: /* BuiltinV */3,
                            _0: {
                              bName: "<builtin: zero?>",
                              bProc: zeroP
                            }
                          }
                        ],
                        tl: {
                          hd: [
                            /* Name */{
                              _0: "cons"
                            },
                            {
                              TAG: /* BuiltinV */3,
                              _0: {
                                bName: "<builtin: cons>",
                                bProc: cons
                              }
                            }
                          ],
                          tl: {
                            hd: [
                              /* Name */{
                                _0: "first"
                              },
                              {
                                TAG: /* BuiltinV */3,
                                _0: {
                                  bName: "<builtin: first>",
                                  bProc: first
                                }
                              }
                            ],
                            tl: {
                              hd: [
                                /* Name */{
                                  _0: "rest"
                                },
                                {
                                  TAG: /* BuiltinV */3,
                                  _0: {
                                    bName: "<builtin: rest>",
                                    bProc: rest
                                  }
                                }
                              ],
                              tl: {
                                hd: [
                                  /* Name */{
                                    _0: "empty?"
                                  },
                                  {
                                    TAG: /* BuiltinV */3,
                                    _0: {
                                      bName: "<builtin: empty?>",
                                      bProc: emptyP
                                    }
                                  }
                                ],
                                tl: {
                                  hd: [
                                    /* Name */{
                                      _0: "cons?"
                                    },
                                    {
                                      TAG: /* BuiltinV */3,
                                      _0: {
                                        bName: "<builtin: cons?>",
                                        bProc: consP
                                      }
                                    }
                                  ],
                                  tl: {
                                    hd: [
                                      /* Name */{
                                        _0: "not"
                                      },
                                      {
                                        TAG: /* BuiltinV */3,
                                        _0: {
                                          bName: "<builtin: not>",
                                          bProc: not_
                                        }
                                      }
                                    ],
                                    tl: {
                                      hd: [
                                        /* Name */{
                                          _0: "list"
                                        },
                                        {
                                          TAG: /* BuiltinV */3,
                                          _0: {
                                            bName: "<builtin: list>",
                                            bProc: list
                                          }
                                        }
                                      ],
                                      tl: /* [] */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

var initialTle = {
  hd: initialTle_0,
  tl: initialTle_1
};

function parseExpression(input) {
  var condHelper = function (input) {
    if (!input) {
      return /* [] */0;
    }
    var match = input.hd;
    switch (match.TAG | 0) {
      case /* NumberC */0 :
      case /* SymbolC */1 :
          return Pervasives.failwith("invalid condData");
      case /* ListC */2 :
          var match$1 = match._0;
          if (!match$1) {
            return Pervasives.failwith("invalid condData");
          }
          var match$2 = match$1.tl;
          if (match$2 && !match$2.tl) {
            return {
                    hd: {
                      conditionExpr: parseExpression(match$1.hd),
                      resultExpr: parseExpression(match$2.hd)
                    },
                    tl: condHelper(input.tl)
                  };
          } else {
            return Pervasives.failwith("invalid condData");
          }
      
    }
  };
  var nameHelper = function (input) {
    switch (input.TAG | 0) {
      case /* SymbolC */1 :
          var n = input._0;
          switch (n) {
            case "and" :
            case "cond" :
            case "define" :
            case "empty" :
            case "false" :
            case "if" :
            case "lambda" :
            case "let" :
            case "or" :
            case "true" :
                return Pervasives.failwith("invalid name");
            default:
              return /* Name */{
                      _0: n
                    };
          }
      case /* NumberC */0 :
      case /* ListC */2 :
          return Pervasives.failwith("invalid name");
      
    }
  };
  var letPairsHelper = function (input) {
    if (!input) {
      return /* [] */0;
    }
    var match = input.hd;
    switch (match.TAG | 0) {
      case /* NumberC */0 :
      case /* SymbolC */1 :
          return Pervasives.failwith("invalid let pair");
      case /* ListC */2 :
          var match$1 = match._0;
          if (!match$1) {
            return Pervasives.failwith("invalid let pair");
          }
          var item1 = match$1.hd;
          switch (item1.TAG | 0) {
            case /* SymbolC */1 :
                var match$2 = match$1.tl;
                if (match$2 && !match$2.tl) {
                  return {
                          hd: {
                            pairName: /* Name */{
                              _0: item1._0
                            },
                            pairExpr: parseExpression(match$2.hd)
                          },
                          tl: letPairsHelper(input.tl)
                        };
                } else {
                  return Pervasives.failwith("invalid let pair");
                }
            case /* NumberC */0 :
            case /* ListC */2 :
                return Pervasives.failwith("invalid let pair");
            
          }
      
    }
  };
  switch (input.TAG | 0) {
    case /* NumberC */0 :
        return {
                TAG: /* NumE */0,
                _0: input._0
              };
    case /* SymbolC */1 :
        var n = input._0;
        switch (n) {
          case "empty" :
              return /* EmptyE */0;
          case "false" :
              return {
                      TAG: /* BoolE */1,
                      _0: false
                    };
          case "true" :
              return {
                      TAG: /* BoolE */1,
                      _0: true
                    };
          default:
            return {
                    TAG: /* NameE */2,
                    _0: nameHelper({
                          TAG: /* SymbolC */1,
                          _0: n
                        })
                  };
        }
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return Pervasives.failwith("Cannot parse an empty list");
        }
        var $$int = match.hd;
        switch ($$int.TAG | 0) {
          case /* NumberC */0 :
              return {
                      TAG: /* ApplicationE */9,
                      _0: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: $$int._0
                        },
                        tl: List.map(parseExpression, match.tl)
                      }
                    };
          case /* SymbolC */1 :
              var n$1 = $$int._0;
              switch (n$1) {
                case "and" :
                    var match$1 = match.tl;
                    if (!match$1) {
                      return Pervasives.failwith("And needs to take in two expressions");
                    }
                    var match$2 = match$1.tl;
                    if (match$2 && !match$2.tl) {
                      return {
                              TAG: /* AndE */3,
                              _0: parseExpression(match$1.hd),
                              _1: parseExpression(match$2.hd)
                            };
                    } else {
                      return Pervasives.failwith("And needs to take in two expressions");
                    }
                case "cond" :
                    var match$3 = match.tl;
                    if (!match$3) {
                      return Pervasives.failwith("Cond needs to take in at least a pair of valid condData");
                    }
                    var match$4 = match$3.hd;
                    switch (match$4.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return Pervasives.failwith("Cond needs to take in at least a pair of valid condData");
                      case /* ListC */2 :
                          var match$5 = match$4._0;
                          if (!match$5) {
                            return Pervasives.failwith("Cond needs to take in at least a pair of valid condData");
                          }
                          var match$6 = match$5.tl;
                          if (match$6 && !match$6.tl) {
                            return {
                                    TAG: /* CondE */6,
                                    _0: {
                                      hd: {
                                        conditionExpr: parseExpression(match$5.hd),
                                        resultExpr: parseExpression(match$6.hd)
                                      },
                                      tl: condHelper(match$3.tl)
                                    }
                                  };
                          } else {
                            return Pervasives.failwith("Cond needs to take in at least a pair of valid condData");
                          }
                      
                    }
                case "if" :
                    var match$7 = match.tl;
                    if (!match$7) {
                      return Pervasives.failwith("If needs to take in three expressions");
                    }
                    var match$8 = match$7.tl;
                    if (!match$8) {
                      return Pervasives.failwith("If needs to take in three expressions");
                    }
                    var match$9 = match$8.tl;
                    if (match$9 && !match$9.tl) {
                      return {
                              TAG: /* IfE */5,
                              _0: {
                                boolExpr: parseExpression(match$7.hd),
                                trueExpr: parseExpression(match$8.hd),
                                falseExpr: parseExpression(match$9.hd)
                              }
                            };
                    } else {
                      return Pervasives.failwith("If needs to take in three expressions");
                    }
                case "lambda" :
                    var match$10 = match.tl;
                    if (!match$10) {
                      return Pervasives.failwith("Lambda needs to take in a list of names and an expression");
                    }
                    var match$11 = match$10.hd;
                    switch (match$11.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return Pervasives.failwith("Lambda needs to take in a list of names and an expression");
                      case /* ListC */2 :
                          var match$12 = match$11._0;
                          if (match$12) {
                            var match$13 = match$10.tl;
                            if (match$13 && !match$13.tl) {
                              return {
                                      TAG: /* LambdaE */7,
                                      _0: {
                                        nameList: List.map(nameHelper, {
                                              hd: match$12.hd,
                                              tl: match$12.tl
                                            }),
                                        lambdaBody: parseExpression(match$13.hd)
                                      }
                                    };
                            } else {
                              return Pervasives.failwith("Lambda needs to take in a list of names and an expression");
                            }
                          }
                          var match$14 = match$10.tl;
                          if (match$14 && !match$14.tl) {
                            return {
                                    TAG: /* LambdaE */7,
                                    _0: {
                                      nameList: /* [] */0,
                                      lambdaBody: parseExpression(match$14.hd)
                                    }
                                  };
                          } else {
                            return Pervasives.failwith("Lambda needs to take in a list of names and an expression");
                          }
                      
                    }
                case "let" :
                    var match$15 = match.tl;
                    if (!match$15) {
                      return Pervasives.failwith("Let needs to take in a list of pairs and an expression");
                    }
                    var item1 = match$15.hd;
                    switch (item1.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return Pervasives.failwith("Let needs to take in a list of pairs and an expression");
                      case /* ListC */2 :
                          var match$16 = match$15.tl;
                          if (match$16 && !match$16.tl) {
                            return {
                                    TAG: /* LetE */8,
                                    _0: {
                                      letPairs: letPairsHelper(item1._0),
                                      letBody: parseExpression(match$16.hd)
                                    }
                                  };
                          } else {
                            return Pervasives.failwith("Let needs to take in a list of pairs and an expression");
                          }
                      
                    }
                case "or" :
                    var match$17 = match.tl;
                    if (!match$17) {
                      return Pervasives.failwith("Or needs to take in two expressions");
                    }
                    var match$18 = match$17.tl;
                    if (match$18 && !match$18.tl) {
                      return {
                              TAG: /* OrE */4,
                              _0: parseExpression(match$17.hd),
                              _1: parseExpression(match$18.hd)
                            };
                    } else {
                      return Pervasives.failwith("Or needs to take in two expressions");
                    }
                default:
                  return {
                          TAG: /* ApplicationE */9,
                          _0: {
                            hd: {
                              TAG: /* NameE */2,
                              _0: nameHelper({
                                    TAG: /* SymbolC */1,
                                    _0: n$1
                                  })
                            },
                            tl: List.map(parseExpression, match.tl)
                          }
                        };
              }
          case /* ListC */2 :
              return {
                      TAG: /* ApplicationE */9,
                      _0: List.map(parseExpression, {
                            hd: {
                              TAG: /* ListC */2,
                              _0: $$int._0
                            },
                            tl: match.tl
                          })
                    };
          
        }
    
  }
}

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* NumberC */0,
          _0: 3
        }), {
      TAG: /* NumE */0,
      _0: 3
    }, "parse expression with num");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "true"
        }), {
      TAG: /* BoolE */1,
      _0: true
    }, "parse expression with true");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "false"
        }), {
      TAG: /* BoolE */1,
      _0: false
    }, "parse expression with false");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "empty"
        }), /* EmptyE */0, "parse expression with empty");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "football"
        }), {
      TAG: /* NameE */2,
      _0: /* Name */{
        _0: "football"
      }
    }, "parse expression with name");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "and"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "false"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "true"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* AndE */3,
      _0: {
        TAG: /* BoolE */1,
        _0: false
      },
      _1: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "parse expression with and");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "or"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "false"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "true"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* OrE */4,
      _0: {
        TAG: /* BoolE */1,
        _0: false
      },
      _1: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "parse expression with or");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "if"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 3
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 4
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }), {
      TAG: /* IfE */5,
      _0: {
        boolExpr: {
          TAG: /* BoolE */1,
          _0: true
        },
        trueExpr: {
          TAG: /* NumE */0,
          _0: 3
        },
        falseExpr: {
          TAG: /* NumE */0,
          _0: 4
        }
      }
    }, "parse expression with if");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "cond"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "false"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 3
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "true"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 4
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "true"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 5
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }), {
      TAG: /* CondE */6,
      _0: {
        hd: {
          conditionExpr: {
            TAG: /* BoolE */1,
            _0: false
          },
          resultExpr: {
            TAG: /* NumE */0,
            _0: 3
          }
        },
        tl: {
          hd: {
            conditionExpr: {
              TAG: /* BoolE */1,
              _0: true
            },
            resultExpr: {
              TAG: /* NumE */0,
              _0: 4
            }
          },
          tl: {
            hd: {
              conditionExpr: {
                TAG: /* BoolE */1,
                _0: true
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 5
              }
            },
            tl: /* [] */0
          }
        }
      }
    }, "parse expression with cond");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "lambda"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "x"
                  },
                  tl: /* [] */0
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "+"
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 12
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: /* [] */0
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 12
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parse expression with lambda");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "lambda"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: /* [] */0
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 12
                    },
                    tl: /* [] */0
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: /* [] */0,
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NumE */0,
              _0: 12
            },
            tl: /* [] */0
          }
        }
      }
    }, "parse expression with lambda with empty name list");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "let"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 12
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* ListC */2,
                      _0: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "y"
                        },
                        tl: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 13
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 100
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 12
            }
          },
          tl: {
            hd: {
              pairName: /* Name */{
                _0: "y"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 13
              }
            },
            tl: /* [] */0
          }
        },
        letBody: {
          TAG: /* NumE */0,
          _0: 100
        }
      }
    }, "parse expression with let");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "+"
            },
            tl: {
              hd: {
                TAG: /* NumberC */0,
                _0: 23
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 45
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "+"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 23
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 45
            },
            tl: /* [] */0
          }
        }
      }
    }, "parse expression with application");

function parseDefinition(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("invalid definition");
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return Pervasives.failwith("invalid definition");
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 !== "define") {
                return Pervasives.failwith("invalid definition");
              }
              var match$2 = match.tl;
              if (!match$2) {
                return Pervasives.failwith("invalid definition");
              }
              var a = match$2.hd;
              switch (a.TAG | 0) {
                case /* SymbolC */1 :
                    var match$3 = match$2.tl;
                    if (!match$3) {
                      return Pervasives.failwith("invalid definition");
                    }
                    if (match$3.tl) {
                      return Pervasives.failwith("invalid definition");
                    }
                    var a$1 = a._0;
                    switch (a$1) {
                      case "and" :
                      case "cond" :
                      case "define" :
                      case "empty" :
                      case "false" :
                      case "if" :
                      case "lambda" :
                      case "let" :
                      case "or" :
                      case "true" :
                          return Pervasives.failwith("cannot redefine a reserved keyword");
                      default:
                        return [
                                /* Name */{
                                  _0: a$1
                                },
                                parseExpression(match$3.hd)
                              ];
                    }
                case /* NumberC */0 :
                case /* ListC */2 :
                    return Pervasives.failwith("invalid definition");
                
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return Pervasives.failwith("invalid definition");
          
        }
    
  }
}

CS17SetupRackette$Rackette.checkError((function (param) {
        return parseDefinition({
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "define"
                      },
                      tl: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "define"
                        },
                        tl: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 6
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  });
      }), "cannot redefine a reserved keyword");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "singer"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 6
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "singer"
      },
      {
        TAG: /* NumE */0,
        _0: 6
      }
    ], "parse definition on singer");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "adding"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "+"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 6
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 8
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "adding"
      },
      {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "+"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 6
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 8
              },
              tl: /* [] */0
            }
          }
        }
      }
    ], "parse definition on adding");

function parsePiece(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return {
                TAG: /* Expression */1,
                _0: parseExpression(input)
              };
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return {
                  TAG: /* Expression */1,
                  _0: parseExpression(input)
                };
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 === "define") {
                return {
                        TAG: /* Definition */0,
                        _0: parseDefinition(input)
                      };
              } else {
                return {
                        TAG: /* Expression */1,
                        _0: parseExpression(input)
                      };
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return {
                      TAG: /* Expression */1,
                      _0: parseExpression(input)
                    };
          
        }
    
  }
}

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece({
      TAG: /* Expression */1,
      _0: parseExpression({
            TAG: /* NumberC */0,
            _0: 3
          })
    }, {
      TAG: /* Expression */1,
      _0: {
        TAG: /* NumE */0,
        _0: 3
      }
    }, "parse piece with num");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece({
      TAG: /* Expression */1,
      _0: parseExpression({
            TAG: /* SymbolC */1,
            _0: "true"
          })
    }, {
      TAG: /* Expression */1,
      _0: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "parse piece with bool");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece({
      TAG: /* Expression */1,
      _0: parseExpression({
            TAG: /* SymbolC */1,
            _0: "empty"
          })
    }, {
      TAG: /* Expression */1,
      _0: /* EmptyE */0
    }, "parse piece with empty");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece({
      TAG: /* Expression */1,
      _0: parseExpression({
            TAG: /* SymbolC */1,
            _0: "football"
          })
    }, {
      TAG: /* Expression */1,
      _0: {
        TAG: /* NameE */2,
        _0: /* Name */{
          _0: "football"
        }
      }
    }, "parse piece with name");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "and"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "false"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "true"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* AndE */3,
        _0: {
          TAG: /* BoolE */1,
          _0: false
        },
        _1: {
          TAG: /* BoolE */1,
          _0: true
        }
      }
    }, "parse piece with and");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "or"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "false"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "true"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* OrE */4,
        _0: {
          TAG: /* BoolE */1,
          _0: false
        },
        _1: {
          TAG: /* BoolE */1,
          _0: true
        }
      }
    }, "parse piece with or");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "if"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 3
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 4
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* IfE */5,
        _0: {
          boolExpr: {
            TAG: /* BoolE */1,
            _0: true
          },
          trueExpr: {
            TAG: /* NumE */0,
            _0: 3
          },
          falseExpr: {
            TAG: /* NumE */0,
            _0: 4
          }
        }
      }
    }, "parse piece with if");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "cond"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "false"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 3
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "true"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 4
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "true"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 5
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* CondE */6,
        _0: {
          hd: {
            conditionExpr: {
              TAG: /* BoolE */1,
              _0: false
            },
            resultExpr: {
              TAG: /* NumE */0,
              _0: 3
            }
          },
          tl: {
            hd: {
              conditionExpr: {
                TAG: /* BoolE */1,
                _0: true
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 4
              }
            },
            tl: {
              hd: {
                conditionExpr: {
                  TAG: /* BoolE */1,
                  _0: true
                },
                resultExpr: {
                  TAG: /* NumE */0,
                  _0: 5
                }
              },
              tl: /* [] */0
            }
          }
        }
      }
    }, "parse piece with cond");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "lambda"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "x"
                  },
                  tl: /* [] */0
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "+"
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 12
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* LambdaE */7,
        _0: {
          nameList: {
            hd: /* Name */{
              _0: "x"
            },
            tl: /* [] */0
          },
          lambdaBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 12
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    }, "parse piece with lambda");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "let"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 12
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* ListC */2,
                      _0: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "y"
                        },
                        tl: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 13
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 100
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* LetE */8,
        _0: {
          letPairs: {
            hd: {
              pairName: /* Name */{
                _0: "x"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 12
              }
            },
            tl: {
              hd: {
                pairName: /* Name */{
                  _0: "y"
                },
                pairExpr: {
                  TAG: /* NumE */0,
                  _0: 13
                }
              },
              tl: /* [] */0
            }
          },
          letBody: {
            TAG: /* NumE */0,
            _0: 100
          }
        }
      }
    }, "parse piece with let");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "+"
            },
            tl: {
              hd: {
                TAG: /* NumberC */0,
                _0: 23
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 45
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "+"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 23
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 45
              },
              tl: /* [] */0
            }
          }
        }
      }
    }, "parse piece with application");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "x"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Definition */0,
      _0: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumE */0,
          _0: 3
        }
      ]
    }, "parse piece with definition");

function parse(input) {
  return List.map(parsePiece, input);
}

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* NumberC */0,
            _0: 3
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* NumE */0,
          _0: 3
        }
      },
      tl: /* [] */0
    }, "parse with num");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* SymbolC */1,
            _0: "true"
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* BoolE */1,
          _0: true
        }
      },
      tl: /* [] */0
    }, "parse with bool");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* SymbolC */1,
            _0: "empty"
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: /* EmptyE */0
      },
      tl: /* [] */0
    }, "parse with empty");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* SymbolC */1,
            _0: "football"
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "football"
          }
        }
      },
      tl: /* [] */0
    }, "parse with name");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "and"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "true"
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* AndE */3,
          _0: {
            TAG: /* BoolE */1,
            _0: false
          },
          _1: {
            TAG: /* BoolE */1,
            _0: true
          }
        }
      },
      tl: /* [] */0
    }, "parse with and");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "or"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "true"
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* OrE */4,
          _0: {
            TAG: /* BoolE */1,
            _0: false
          },
          _1: {
            TAG: /* BoolE */1,
            _0: true
          }
        }
      },
      tl: /* [] */0
    }, "parse with or");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "if"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "true"
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 3
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 4
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* IfE */5,
          _0: {
            boolExpr: {
              TAG: /* BoolE */1,
              _0: true
            },
            trueExpr: {
              TAG: /* NumE */0,
              _0: 3
            },
            falseExpr: {
              TAG: /* NumE */0,
              _0: 4
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with if");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "cond"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "false"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 3
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "true"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 4
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* ListC */2,
                      _0: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "true"
                        },
                        tl: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 5
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* CondE */6,
          _0: {
            hd: {
              conditionExpr: {
                TAG: /* BoolE */1,
                _0: false
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 3
              }
            },
            tl: {
              hd: {
                conditionExpr: {
                  TAG: /* BoolE */1,
                  _0: true
                },
                resultExpr: {
                  TAG: /* NumE */0,
                  _0: 4
                }
              },
              tl: {
                hd: {
                  conditionExpr: {
                    TAG: /* BoolE */1,
                    _0: true
                  },
                  resultExpr: {
                    TAG: /* NumE */0,
                    _0: 5
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with cond");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "lambda"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "x"
                    },
                    tl: /* [] */0
                  }
                },
                tl: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "+"
                      },
                      tl: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "x"
                        },
                        tl: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 12
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "x"
              },
              tl: /* [] */0
            },
            lambdaBody: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 12
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with lambda");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "let"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* ListC */2,
                      _0: {
                        hd: {
                          TAG: /* SymbolC */1,
                          _0: "x"
                        },
                        tl: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 12
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "y"
                          },
                          tl: {
                            hd: {
                              TAG: /* NumberC */0,
                              _0: 13
                            },
                            tl: /* [] */0
                          }
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 100
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* LetE */8,
          _0: {
            letPairs: {
              hd: {
                pairName: /* Name */{
                  _0: "x"
                },
                pairExpr: {
                  TAG: /* NumE */0,
                  _0: 12
                }
              },
              tl: {
                hd: {
                  pairName: /* Name */{
                    _0: "y"
                  },
                  pairExpr: {
                    TAG: /* NumE */0,
                    _0: 13
                  }
                },
                tl: /* [] */0
              }
            },
            letBody: {
              TAG: /* NumE */0,
              _0: 100
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with let");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "+"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 23
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 45
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 23
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 45
                },
                tl: /* [] */0
              }
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with application");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, {
          hd: {
            TAG: /* ListC */2,
            _0: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "define"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "x"
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 3
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* Definition */0,
        _0: [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 3
          }
        ]
      },
      tl: /* [] */0
    }, "parse with definition");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("3")), {
      TAG: /* NumE */0,
      _0: 3
    }, "parse expression and read with num");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("true")), {
      TAG: /* BoolE */1,
      _0: true
    }, "parse expression and read with true");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("false")), {
      TAG: /* BoolE */1,
      _0: false
    }, "parse expression and read with false");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("empty")), /* EmptyE */0, "parse expression and read with empty");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("football")), {
      TAG: /* NameE */2,
      _0: /* Name */{
        _0: "football"
      }
    }, "parse expression and read with name");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(and false true)")), {
      TAG: /* AndE */3,
      _0: {
        TAG: /* BoolE */1,
        _0: false
      },
      _1: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "parse expression and read with and");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(or false true)")), {
      TAG: /* OrE */4,
      _0: {
        TAG: /* BoolE */1,
        _0: false
      },
      _1: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "parse expression and read with or");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(if true 3 4)")), {
      TAG: /* IfE */5,
      _0: {
        boolExpr: {
          TAG: /* BoolE */1,
          _0: true
        },
        trueExpr: {
          TAG: /* NumE */0,
          _0: 3
        },
        falseExpr: {
          TAG: /* NumE */0,
          _0: 4
        }
      }
    }, "parse expression and read with if");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(cond (false 3) (true 4) (true 5))")), {
      TAG: /* CondE */6,
      _0: {
        hd: {
          conditionExpr: {
            TAG: /* BoolE */1,
            _0: false
          },
          resultExpr: {
            TAG: /* NumE */0,
            _0: 3
          }
        },
        tl: {
          hd: {
            conditionExpr: {
              TAG: /* BoolE */1,
              _0: true
            },
            resultExpr: {
              TAG: /* NumE */0,
              _0: 4
            }
          },
          tl: {
            hd: {
              conditionExpr: {
                TAG: /* BoolE */1,
                _0: true
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 5
              }
            },
            tl: /* [] */0
          }
        }
      }
    }, "parse expression and read with cond");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(lambda (x) (+ x 12))")), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: /* [] */0
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 12
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parse expression and read with lambda");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(let ((x 12) (y 13)) 100)")), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 12
            }
          },
          tl: {
            hd: {
              pairName: /* Name */{
                _0: "y"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 13
              }
            },
            tl: /* [] */0
          }
        },
        letBody: {
          TAG: /* NumE */0,
          _0: 100
        }
      }
    }, "parse expression and read with let");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(+ 23 45)")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "+"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 23
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 45
            },
            tl: /* [] */0
          }
        }
      }
    }, "parse expression and read with application");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition(Read$Rackette.Reader.read("(define singer 6)")), [
      /* Name */{
        _0: "singer"
      },
      {
        TAG: /* NumE */0,
        _0: 6
      }
    ], "parse definition and read on singer");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition(Read$Rackette.Reader.read("(define adding (+ 6 8))")), [
      /* Name */{
        _0: "adding"
      },
      {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "+"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 6
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 8
              },
              tl: /* [] */0
            }
          }
        }
      }
    ], "parse definition and read on adding");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("3")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* NumE */0,
        _0: 3
      }
    }, "parse piece and read with num");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("true")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "parse piece and read with bool");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("empty")), {
      TAG: /* Expression */1,
      _0: /* EmptyE */0
    }, "parse piece and read with empty");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("football")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* NameE */2,
        _0: /* Name */{
          _0: "football"
        }
      }
    }, "parse piece and read with name");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(and false true)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* AndE */3,
        _0: {
          TAG: /* BoolE */1,
          _0: false
        },
        _1: {
          TAG: /* BoolE */1,
          _0: true
        }
      }
    }, "parse piece and read with and");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(or false true)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* OrE */4,
        _0: {
          TAG: /* BoolE */1,
          _0: false
        },
        _1: {
          TAG: /* BoolE */1,
          _0: true
        }
      }
    }, "parse piece and read with or");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(if true 3 4)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* IfE */5,
        _0: {
          boolExpr: {
            TAG: /* BoolE */1,
            _0: true
          },
          trueExpr: {
            TAG: /* NumE */0,
            _0: 3
          },
          falseExpr: {
            TAG: /* NumE */0,
            _0: 4
          }
        }
      }
    }, "parse piece and read with if");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(cond (false 3) (true 4) (true 5))")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* CondE */6,
        _0: {
          hd: {
            conditionExpr: {
              TAG: /* BoolE */1,
              _0: false
            },
            resultExpr: {
              TAG: /* NumE */0,
              _0: 3
            }
          },
          tl: {
            hd: {
              conditionExpr: {
                TAG: /* BoolE */1,
                _0: true
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 4
              }
            },
            tl: {
              hd: {
                conditionExpr: {
                  TAG: /* BoolE */1,
                  _0: true
                },
                resultExpr: {
                  TAG: /* NumE */0,
                  _0: 5
                }
              },
              tl: /* [] */0
            }
          }
        }
      }
    }, "parse piece and read with cond");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(lambda (x) (+ x 12))")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* LambdaE */7,
        _0: {
          nameList: {
            hd: /* Name */{
              _0: "x"
            },
            tl: /* [] */0
          },
          lambdaBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 12
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    }, "parse piece and read with lambda");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(let ((x 12) (y 13)) 100)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* LetE */8,
        _0: {
          letPairs: {
            hd: {
              pairName: /* Name */{
                _0: "x"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 12
              }
            },
            tl: {
              hd: {
                pairName: /* Name */{
                  _0: "y"
                },
                pairExpr: {
                  TAG: /* NumE */0,
                  _0: 13
                }
              },
              tl: /* [] */0
            }
          },
          letBody: {
            TAG: /* NumE */0,
            _0: 100
          }
        }
      }
    }, "parse piece and read with let");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(+ 23 45)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "+"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 23
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 45
              },
              tl: /* [] */0
            }
          }
        }
      }
    }, "parse piece and read with application");

CS17SetupRackette$Rackette.checkExpectAbstractProgramPiece(parsePiece(Read$Rackette.Reader.read("(define x 3)")), {
      TAG: /* Definition */0,
      _0: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumE */0,
          _0: 3
        }
      ]
    }, "parse piece and read with definition");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("3")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* NumE */0,
          _0: 3
        }
      },
      tl: /* [] */0
    }, "parse with num");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("true")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* BoolE */1,
          _0: true
        }
      },
      tl: /* [] */0
    }, "parse with bool");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("empty")), {
      hd: {
        TAG: /* Expression */1,
        _0: /* EmptyE */0
      },
      tl: /* [] */0
    }, "parse with empty");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("football")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "football"
          }
        }
      },
      tl: /* [] */0
    }, "parse with name");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(and false true)")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* AndE */3,
          _0: {
            TAG: /* BoolE */1,
            _0: false
          },
          _1: {
            TAG: /* BoolE */1,
            _0: true
          }
        }
      },
      tl: /* [] */0
    }, "parse with and");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(or false true)")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* OrE */4,
          _0: {
            TAG: /* BoolE */1,
            _0: false
          },
          _1: {
            TAG: /* BoolE */1,
            _0: true
          }
        }
      },
      tl: /* [] */0
    }, "parse with or");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(if true 3 4)")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* IfE */5,
          _0: {
            boolExpr: {
              TAG: /* BoolE */1,
              _0: true
            },
            trueExpr: {
              TAG: /* NumE */0,
              _0: 3
            },
            falseExpr: {
              TAG: /* NumE */0,
              _0: 4
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with if");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(cond (false 3) (true 4) (true 5))")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* CondE */6,
          _0: {
            hd: {
              conditionExpr: {
                TAG: /* BoolE */1,
                _0: false
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 3
              }
            },
            tl: {
              hd: {
                conditionExpr: {
                  TAG: /* BoolE */1,
                  _0: true
                },
                resultExpr: {
                  TAG: /* NumE */0,
                  _0: 4
                }
              },
              tl: {
                hd: {
                  conditionExpr: {
                    TAG: /* BoolE */1,
                    _0: true
                  },
                  resultExpr: {
                    TAG: /* NumE */0,
                    _0: 5
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with cond");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(lambda (x) (+ x 12))")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "x"
              },
              tl: /* [] */0
            },
            lambdaBody: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 12
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with lambda");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(let ((x 12) (y 13)) 100)")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* LetE */8,
          _0: {
            letPairs: {
              hd: {
                pairName: /* Name */{
                  _0: "x"
                },
                pairExpr: {
                  TAG: /* NumE */0,
                  _0: 12
                }
              },
              tl: {
                hd: {
                  pairName: /* Name */{
                    _0: "y"
                  },
                  pairExpr: {
                    TAG: /* NumE */0,
                    _0: 13
                  }
                },
                tl: /* [] */0
              }
            },
            letBody: {
              TAG: /* NumE */0,
              _0: 100
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with let");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(+ 23 45)")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 23
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 45
                },
                tl: /* [] */0
              }
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse with application");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(define x 3)")), {
      hd: {
        TAG: /* Definition */0,
        _0: [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 3
          }
        ]
      },
      tl: /* [] */0
    }, "parse and read with definition");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("((lambda (x y) ((lambda (y) (+ x y)) x )) 17 18)")), {
      hd: {
        TAG: /* Expression */1,
        _0: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: {
                    hd: /* Name */{
                      _0: "y"
                    },
                    tl: /* [] */0
                  }
                },
                lambdaBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* LambdaE */7,
                      _0: {
                        nameList: {
                          hd: /* Name */{
                            _0: "y"
                          },
                          tl: /* [] */0
                        },
                        lambdaBody: {
                          TAG: /* ApplicationE */9,
                          _0: {
                            hd: {
                              TAG: /* NameE */2,
                              _0: /* Name */{
                                _0: "+"
                              }
                            },
                            tl: {
                              hd: {
                                TAG: /* NameE */2,
                                _0: /* Name */{
                                  _0: "x"
                                }
                              },
                              tl: {
                                hd: {
                                  TAG: /* NameE */2,
                                  _0: /* Name */{
                                    _0: "y"
                                  }
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        }
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 17
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 18
                },
                tl: /* [] */0
              }
            }
          }
        }
      },
      tl: /* [] */0
    }, "parse and read with a nested lambda");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(define lengthen2 (lambda (alon) (cons 9 alon))) \n      (lengthen2 (list 2 3))")), {
      hd: {
        TAG: /* Definition */0,
        _0: [
          /* Name */{
            _0: "lengthen2"
          },
          {
            TAG: /* LambdaE */7,
            _0: {
              nameList: {
                hd: /* Name */{
                  _0: "alon"
                },
                tl: /* [] */0
              },
              lambdaBody: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "cons"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 9
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "alon"
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            }
          }
        ]
      },
      tl: {
        hd: {
          TAG: /* Expression */1,
          _0: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "lengthen2"
                }
              },
              tl: {
                hd: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "list"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 2
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 3
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        },
        tl: /* [] */0
      }
    }, "parse and read with a definition and application");

CS17SetupRackette$Rackette.checkExpectAbstractProgram(List.map(parsePiece, Read$Rackette.Reader.readAll("(define flip (lambda (alops) (cond ((empty? alops) empty) ((cons? alops)\n      (cons (list (second (first alops)) (first (first alops)))\n      (flip (rest alops)))))))")), {
      hd: {
        TAG: /* Definition */0,
        _0: [
          /* Name */{
            _0: "flip"
          },
          {
            TAG: /* LambdaE */7,
            _0: {
              nameList: {
                hd: /* Name */{
                  _0: "alops"
                },
                tl: /* [] */0
              },
              lambdaBody: {
                TAG: /* CondE */6,
                _0: {
                  hd: {
                    conditionExpr: {
                      TAG: /* ApplicationE */9,
                      _0: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "empty?"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "alops"
                            }
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    resultExpr: /* EmptyE */0
                  },
                  tl: {
                    hd: {
                      conditionExpr: {
                        TAG: /* ApplicationE */9,
                        _0: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "cons?"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* NameE */2,
                              _0: /* Name */{
                                _0: "alops"
                              }
                            },
                            tl: /* [] */0
                          }
                        }
                      },
                      resultExpr: {
                        TAG: /* ApplicationE */9,
                        _0: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "cons"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* ApplicationE */9,
                              _0: {
                                hd: {
                                  TAG: /* NameE */2,
                                  _0: /* Name */{
                                    _0: "list"
                                  }
                                },
                                tl: {
                                  hd: {
                                    TAG: /* ApplicationE */9,
                                    _0: {
                                      hd: {
                                        TAG: /* NameE */2,
                                        _0: /* Name */{
                                          _0: "second"
                                        }
                                      },
                                      tl: {
                                        hd: {
                                          TAG: /* ApplicationE */9,
                                          _0: {
                                            hd: {
                                              TAG: /* NameE */2,
                                              _0: /* Name */{
                                                _0: "first"
                                              }
                                            },
                                            tl: {
                                              hd: {
                                                TAG: /* NameE */2,
                                                _0: /* Name */{
                                                  _0: "alops"
                                                }
                                              },
                                              tl: /* [] */0
                                            }
                                          }
                                        },
                                        tl: /* [] */0
                                      }
                                    }
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* ApplicationE */9,
                                      _0: {
                                        hd: {
                                          TAG: /* NameE */2,
                                          _0: /* Name */{
                                            _0: "first"
                                          }
                                        },
                                        tl: {
                                          hd: {
                                            TAG: /* ApplicationE */9,
                                            _0: {
                                              hd: {
                                                TAG: /* NameE */2,
                                                _0: /* Name */{
                                                  _0: "first"
                                                }
                                              },
                                              tl: {
                                                hd: {
                                                  TAG: /* NameE */2,
                                                  _0: /* Name */{
                                                    _0: "alops"
                                                  }
                                                },
                                                tl: /* [] */0
                                              }
                                            }
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    },
                                    tl: /* [] */0
                                  }
                                }
                              }
                            },
                            tl: {
                              hd: {
                                TAG: /* ApplicationE */9,
                                _0: {
                                  hd: {
                                    TAG: /* NameE */2,
                                    _0: /* Name */{
                                      _0: "flip"
                                    }
                                  },
                                  tl: {
                                    hd: {
                                      TAG: /* ApplicationE */9,
                                      _0: {
                                        hd: {
                                          TAG: /* NameE */2,
                                          _0: /* Name */{
                                            _0: "rest"
                                          }
                                        },
                                        tl: {
                                          hd: {
                                            TAG: /* NameE */2,
                                            _0: /* Name */{
                                              _0: "alops"
                                            }
                                          },
                                          tl: /* [] */0
                                        }
                                      }
                                    },
                                    tl: /* [] */0
                                  }
                                }
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        ]
      },
      tl: /* [] */0
    }, "parse and read with a complex program");

function $$eval(tle, _env, _expr) {
  while(true) {
    var expr = _expr;
    var env = _env;
    var duplicateChecker = function (_ln) {
      while(true) {
        var ln = _ln;
        if (!ln) {
          return false;
        }
        var tl = ln.tl;
        if (List.mem(ln.hd, tl)) {
          return true;
        }
        _ln = tl;
        continue ;
      };
    };
    var evalMap = (function(env){
    return function evalMap($$eval, expr) {
      if (expr) {
        return {
                hd: Curry._3($$eval, tle, env, expr.hd),
                tl: evalMap($$eval, expr.tl)
              };
      } else {
        return /* [] */0;
      }
    }
    }(env));
    var lambdaHelper = function (namelist, vallist) {
      if (!namelist) {
        return /* [] */0;
      }
      if (!vallist) {
        return /* [] */0;
      }
      var nametl = namelist.tl;
      var name1 = namelist.hd;
      if (duplicateChecker({
              hd: name1,
              tl: nametl
            })) {
        return Pervasives.failwith("lambda: cannot bound a variable more than once");
      } else {
        return {
                hd: [
                  name1,
                  vallist.hd
                ],
                tl: lambdaHelper(nametl, vallist.tl)
              };
      }
    };
    var letPairHelper = function (lp) {
      if (lp) {
        return {
                hd: lp.hd.pairName,
                tl: letPairHelper(lp.tl)
              };
      } else {
        return /* [] */0;
      }
    };
    var letHelper = (function(env){
    return function letHelper(envl, lp) {
      if (!lp) {
        return /* [] */0;
      }
      var match = lp.hd;
      if (duplicateChecker(letPairHelper(lp))) {
        return Pervasives.failwith("let: cannot bound a variable more than once");
      } else {
        return List.append({
                    hd: [
                      match.pairName,
                      $$eval(tle, env, match.pairExpr)
                    ],
                    tl: letHelper(envl, lp.tl)
                  }, envl);
      }
    }
    }(env));
    if (typeof expr === "number") {
      return {
              TAG: /* ListV */2,
              _0: /* [] */0
            };
    }
    switch (expr.TAG | 0) {
      case /* NumE */0 :
          return {
                  TAG: /* NumV */0,
                  _0: expr._0
                };
      case /* BoolE */1 :
          return {
                  TAG: /* BoolV */1,
                  _0: expr._0
                };
      case /* NameE */2 :
          var _env$1 = List.append(env, tle);
          var nam = expr._0;
          while(true) {
            var env$1 = _env$1;
            if (!env$1) {
              return Pervasives.failwith("lookup error");
            }
            var match = env$1.hd;
            if (Caml_obj.caml_equal(match[0], nam)) {
              return match[1];
            }
            _env$1 = env$1.tl;
            continue ;
          };
      case /* AndE */3 :
          var match$1 = $$eval(tle, env, expr._0);
          if (match$1.TAG !== /* BoolV */1) {
            return Pervasives.failwith("and expects a boolean as first argument");
          }
          if (!match$1._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: false
                  };
          }
          var match$2 = $$eval(tle, env, expr._1);
          if (match$2.TAG === /* BoolV */1) {
            if (match$2._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          } else {
            return Pervasives.failwith("and expects a boolean as second argument");
          }
      case /* OrE */4 :
          var match$3 = $$eval(tle, env, expr._0);
          if (match$3.TAG !== /* BoolV */1) {
            return Pervasives.failwith("or expects a boolean as first argument");
          }
          if (match$3._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: true
                  };
          }
          var match$4 = $$eval(tle, env, expr._1);
          if (match$4.TAG === /* BoolV */1) {
            if (match$4._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          } else {
            return Pervasives.failwith("or expects a boolean as second argument");
          }
      case /* IfE */5 :
          var match$5 = expr._0;
          var match$6 = $$eval(tle, env, match$5.boolExpr);
          if (match$6.TAG !== /* BoolV */1) {
            return Pervasives.failwith("if: first argument must evaluate to a boolean");
          }
          if (match$6._0) {
            _expr = match$5.trueExpr;
            continue ;
          }
          _expr = match$5.falseExpr;
          continue ;
      case /* CondE */6 :
          var match$7 = expr._0;
          if (!match$7) {
            return Pervasives.failwith("all cases were false");
          }
          var match$8 = match$7.hd;
          var match$9 = $$eval(tle, env, match$8.conditionExpr);
          if (match$9.TAG !== /* BoolV */1) {
            return Pervasives.failwith("not a valid cond case");
          }
          if (match$9._0) {
            _expr = match$8.resultExpr;
            continue ;
          }
          _expr = {
            TAG: /* CondE */6,
            _0: match$7.tl
          };
          continue ;
      case /* LambdaE */7 :
          var match$10 = expr._0;
          var namelist = match$10.nameList;
          if (duplicateChecker(namelist)) {
            return Pervasives.failwith("lambda: cannot bound a variable more than once");
          } else {
            return {
                    TAG: /* ClosureV */4,
                    _0: {
                      cNameList: namelist,
                      cExpr: match$10.lambdaBody,
                      cEnv: env
                    }
                  };
          }
      case /* LetE */8 :
          var match$11 = expr._0;
          _expr = match$11.letBody;
          _env = letHelper(env, match$11.letPairs);
          continue ;
      case /* ApplicationE */9 :
          var match$12 = evalMap($$eval, expr._0);
          if (!match$12) {
            return Pervasives.failwith("expected a function after open parenthesis");
          }
          var match$13 = match$12.hd;
          switch (match$13.TAG | 0) {
            case /* BuiltinV */3 :
                return Curry._1(match$13._0.bProc, match$12.tl);
            case /* ClosureV */4 :
                var vallist = match$12.tl;
                var match$14 = match$13._0;
                var namelist$1 = match$14.cNameList;
                if (List.length(namelist$1) !== List.length(vallist)) {
                  return Pervasives.failwith("formals and actuals must have the same number");
                }
                _expr = match$14.cExpr;
                _env = List.append(lambdaHelper(namelist$1, vallist), match$14.cEnv);
                continue ;
            default:
              return Pervasives.failwith("expected a function after open parenthesis");
          }
      
    }
  };
}

function addDefinition(env, param) {
  var id = param[0];
  var addDefHelper = function (_env, id) {
    while(true) {
      var env = _env;
      if (!env) {
        return true;
      }
      if (Caml_obj.caml_equal(id, env.hd[0])) {
        return false;
      }
      _env = env.tl;
      continue ;
    };
  };
  if (addDefHelper(env, id)) {
    return {
            hd: [
              id,
              $$eval(env, /* [] */0, param[1])
            ],
            tl: env
          };
  } else {
    return Pervasives.failwith("cannot redefine");
  }
}

CS17SetupRackette$Rackette.checkExpect(addDefinition(/* [] */0, [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 3
          }
        ]), {
      hd: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumV */0,
          _0: 3
        }
      ],
      tl: /* [] */0
    }, "add definition to an empty environment");

CS17SetupRackette$Rackette.checkExpect(addDefinition({
          hd: [
            /* Name */{
              _0: "y"
            },
            {
              TAG: /* NumV */0,
              _0: 4
            }
          ],
          tl: /* [] */0
        }, [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 3
          }
        ]), {
      hd: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumV */0,
          _0: 3
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "y"
          },
          {
            TAG: /* NumV */0,
            _0: 4
          }
        ],
        tl: /* [] */0
      }
    }, "add definition to a non-empty environment");

function stringOfValue($$int) {
  switch ($$int.TAG | 0) {
    case /* NumV */0 :
        return String($$int._0);
    case /* BoolV */1 :
        return Pervasives.string_of_bool($$int._0);
    case /* ListV */2 :
        var match = $$int._0;
        if (match) {
          return "(cons " + (stringOfValue(match.hd) + (" " + (stringOfValue({
                            TAG: /* ListV */2,
                            _0: match.tl
                          }) + ")")));
        } else {
          return "'()";
        }
    case /* BuiltinV */3 :
        return $$int._0.bName;
    case /* ClosureV */4 :
        return "User-defined procedure";
    
  }
}

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* NumV */0,
          _0: 3
        }), "3", "print a num");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* BoolV */1,
          _0: true
        }), "true", "print a bool");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ListV */2,
          _0: /* [] */0
        }), "'()", "print an empty list");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ListV */2,
          _0: {
            hd: {
              TAG: /* NumV */0,
              _0: 3
            },
            tl: {
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: /* [] */0
            }
          }
        }), "(cons 3 (cons 4 '()))", "print a non-empty list");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ClosureV */4,
          _0: {
            cNameList: {
              hd: /* Name */{
                _0: "x"
              },
              tl: /* [] */0
            },
            cExpr: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 2
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            cEnv: /* [] */0
          }
        }), "User-defined procedure", "print a closure");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* NumE */0,
              _0: 3
            })), "3", "eval and stringOfValue with num");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* BoolE */1,
              _0: false
            })), "false", "eval and stringOfValue with bool");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, /* EmptyE */0)), "'()", "eval and stringOfValue with empty");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            })), "<builtin: + >", "eval and stringOfValue with builtin name");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* AndE */3,
              _0: {
                TAG: /* BoolE */1,
                _0: false
              },
              _1: {
                TAG: /* BoolE */1,
                _0: false
              }
            })), "false", "eval and stringOfValue with and false false");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* AndE */3,
              _0: {
                TAG: /* BoolE */1,
                _0: true
              },
              _1: {
                TAG: /* BoolE */1,
                _0: false
              }
            })), "false", "eval and stringOfValue with and true false");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* AndE */3,
              _0: {
                TAG: /* BoolE */1,
                _0: false
              },
              _1: {
                TAG: /* BoolE */1,
                _0: true
              }
            })), "false", "eval and stringOfValue with and false true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* AndE */3,
              _0: {
                TAG: /* BoolE */1,
                _0: true
              },
              _1: {
                TAG: /* BoolE */1,
                _0: true
              }
            })), "true", "eval and stringOfValue with and true true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* OrE */4,
              _0: {
                TAG: /* BoolE */1,
                _0: false
              },
              _1: {
                TAG: /* BoolE */1,
                _0: false
              }
            })), "false", "eval and stringOfValue with or false false");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* OrE */4,
              _0: {
                TAG: /* BoolE */1,
                _0: true
              },
              _1: {
                TAG: /* BoolE */1,
                _0: false
              }
            })), "true", "eval and stringOfValue with or true false");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* OrE */4,
              _0: {
                TAG: /* BoolE */1,
                _0: false
              },
              _1: {
                TAG: /* BoolE */1,
                _0: true
              }
            })), "true", "eval and stringOfValue with or false true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* OrE */4,
              _0: {
                TAG: /* BoolE */1,
                _0: true
              },
              _1: {
                TAG: /* BoolE */1,
                _0: true
              }
            })), "true", "eval and stringOfValue with or true true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* IfE */5,
              _0: {
                boolExpr: {
                  TAG: /* BoolE */1,
                  _0: false
                },
                trueExpr: {
                  TAG: /* NumE */0,
                  _0: 3
                },
                falseExpr: {
                  TAG: /* NumE */0,
                  _0: 4
                }
              }
            })), "4", "eval and stringOfValue with if");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* CondE */6,
              _0: {
                hd: {
                  conditionExpr: {
                    TAG: /* BoolE */1,
                    _0: false
                  },
                  resultExpr: {
                    TAG: /* NumE */0,
                    _0: 3
                  }
                },
                tl: {
                  hd: {
                    conditionExpr: {
                      TAG: /* BoolE */1,
                      _0: true
                    },
                    resultExpr: {
                      TAG: /* NumE */0,
                      _0: 4
                    }
                  },
                  tl: {
                    hd: {
                      conditionExpr: {
                        TAG: /* BoolE */1,
                        _0: true
                      },
                      resultExpr: {
                        TAG: /* NumE */0,
                        _0: 5
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "4", "eval and stringOfValue with cond");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: /* [] */0
                },
                lambdaBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "+"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 2
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            })), "User-defined procedure", "eval and stringOfValue with lambda");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* LetE */8,
              _0: {
                letPairs: {
                  hd: {
                    pairName: /* Name */{
                      _0: "x"
                    },
                    pairExpr: {
                      TAG: /* NumE */0,
                      _0: 0
                    }
                  },
                  tl: {
                    hd: {
                      pairName: /* Name */{
                        _0: "y"
                      },
                      pairExpr: {
                        TAG: /* NumE */0,
                        _0: 1
                      }
                    },
                    tl: /* [] */0
                  }
                },
                letBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "+"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "y"
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            })), "1", "eval and stringOfValue with let");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 1
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 2
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "3", "eval and stringOfValue with builtin +");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "zero?"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 9
                  },
                  tl: /* [] */0
                }
              }
            })), "false", "eval and stringOfValue with builtin zero?");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* LambdaE */7,
                  _0: {
                    nameList: {
                      hd: /* Name */{
                        _0: "x"
                      },
                      tl: /* [] */0
                    },
                    lambdaBody: {
                      TAG: /* ApplicationE */9,
                      _0: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "+"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "x"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* NumE */0,
                              _0: 2
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 3
                  },
                  tl: /* [] */0
                }
              }
            })), "5", "eval and stringOfValue with lambda and actual");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("3")))), "3", "read and parseExpression and eval and stringOfValue with num");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("true")))), "true", "read and parseExpression and eval and stringOfValue with bool");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("empty")))), "'()", "read and parseExpression and eval and stringOfValue with empty");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("+")))), "<builtin: + >", "read and parseExpression and eval and stringOfValue with builtin name");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(and true false)")))), "false", "read and parseExpression and eval and stringOfValue with and true false");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(and true true)")))), "true", "read and parseExpression and eval and stringOfValue with and true true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(and false false)")))), "false", "read and parseExpression and eval and stringOfValue with and false false");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(and false true)")))), "false", "read and parseExpression and eval and stringOfValue with and false true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(or true false)")))), "true", "read and parseExpression and eval and stringOfValue with or true false");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(or true true)")))), "true", "read and parseExpression and eval and stringOfValue with or true true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(or false false)")))), "false", "read and parseExpression and eval and stringOfValue with or false false");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(or false true)")))), "true", "read and parseExpression and eval and stringOfValue with or false true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(if false 3 5)")))), "5", "read and parseExpression and eval and stringOfValue with if");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(cond (false 3) (true 4) (true 5))")))), "4", "read and parseExpression and eval and stringOfValue with cond");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(lambda (x) (+ x 12))")))), "User-defined procedure", "read and parseExpression and eval and stringOfValue with lambda");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(let ((x 0) (y 1)) (+ x y))")))), "1", "read and parseExpression and eval and stringOfValue with let");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(+ 1 2)")))), "3", "read and parseExpression and eval and stringOfValue with builtin +");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(zero? 9)")))), "false", "read and parseExpression and eval and stringOfValue with builtin zero?");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("((lambda (x) (+ x 2)) 3)")))), "5", "read and parseExpression and eval and stringOfValue with lambda and actual");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("((lambda (x y) ((lambda (y) (+ x y)) x)) 17 18)")))), "34", "read and parseExpression and eval and stringOfValue with nested lambdas");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(let ((x 0) (y 18)) (let ((f (lambda (a b) (+ x b )))(x 17)) (f y x)))")))), "17", "read and parseExpression and eval and stringOfValue withlet and nested lambda within let");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("(let ((x false) (y 1))\n               (cond\n                 ((zero? y) (not x))\n                 ((not (zero? y)) x)))")))), "false", "read and parseExpression and eval and stringOfValue with let and cond");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, parseExpression(Read$Rackette.Reader.read("((lambda (x y z) (+ z\n                 (if (> x y)\n                    (+ x y)\n                    (- x y)))) 1 2 3)")))), "2", "read and parseExpression and eval and stringOfValue with lambda and if");

function $$process(pieces) {
  var processHelper = function (_tle, _pieces) {
    while(true) {
      var pieces = _pieces;
      var tle = _tle;
      if (!pieces) {
        return /* [] */0;
      }
      var d = pieces.hd;
      if (d.TAG !== /* Definition */0) {
        return {
                hd: $$eval(tle, /* [] */0, d._0),
                tl: processHelper(tle, pieces.tl)
              };
      }
      _pieces = pieces.tl;
      _tle = addDefinition(tle, d._0);
      continue ;
    };
  };
  return processHelper(initialTle, pieces);
}

function rackette(program) {
  return List.map(stringOfValue, $$process(List.map(parsePiece, Read$Rackette.Reader.readAll(program))));
}

CS17SetupRackette$Rackette.checkExpect(rackette("3"), {
      hd: "3",
      tl: /* [] */0
    }, "rackette with num");

CS17SetupRackette$Rackette.checkExpect(rackette("true"), {
      hd: "true",
      tl: /* [] */0
    }, "rackette with bool");

CS17SetupRackette$Rackette.checkExpect(rackette("empty"), {
      hd: "'()",
      tl: /* [] */0
    }, "rackette with empty");

CS17SetupRackette$Rackette.checkExpect(rackette("+"), {
      hd: "<builtin: + >",
      tl: /* [] */0
    }, "rackette with builtin name");

CS17SetupRackette$Rackette.checkExpect(rackette("(and true false)"), {
      hd: "false",
      tl: /* [] */0
    }, "rackette with and");

CS17SetupRackette$Rackette.checkExpect(rackette("(or true false)"), {
      hd: "true",
      tl: /* [] */0
    }, "rackette with or");

CS17SetupRackette$Rackette.checkExpect(rackette("(if false 2 3)"), {
      hd: "3",
      tl: /* [] */0
    }, "rackette with if");

CS17SetupRackette$Rackette.checkExpect(rackette("(cond (false 3) (true 54))"), {
      hd: "54",
      tl: /* [] */0
    }, "rackette with cond");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x) (+ x 1)) 9)"), {
      hd: "10",
      tl: /* [] */0
    }, "rackette with lambda and actual");

CS17SetupRackette$Rackette.checkExpect(rackette("(let ((x 0)) (* x 1))"), {
      hd: "0",
      tl: /* [] */0
    }, "rackette with let");

CS17SetupRackette$Rackette.checkExpect(rackette("(cons 2 empty)"), {
      hd: "(cons 2 '())",
      tl: /* [] */0
    }, "rackette with builtin");

CS17SetupRackette$Rackette.checkExpect(rackette("(define f 3) f"), {
      hd: "3",
      tl: /* [] */0
    }, "rackette with define with num");

CS17SetupRackette$Rackette.checkExpect(rackette("(define f false) f"), {
      hd: "false",
      tl: /* [] */0
    }, "rackette with define with bool");

CS17SetupRackette$Rackette.checkExpect(rackette("(define f (lambda (x) (+ x 1))) (f 3)"), {
      hd: "4",
      tl: /* [] */0
    }, "rackette with define with lambda");

CS17SetupRackette$Rackette.checkExpect(rackette("(define my-positive? (lambda (n) (> n 0))) (my-positive? 2)"), {
      hd: "true",
      tl: /* [] */0
    }, "rackette with define with lambda2");

CS17SetupRackette$Rackette.checkExpect(rackette("(define sum-angles (lambda (n) (* 180 (- n 2)))) (sum-angles 3)"), {
      hd: "180",
      tl: /* [] */0
    }, "rackette with define with lambda3");

CS17SetupRackette$Rackette.checkExpect(rackette("(define sum (lambda (n) (/ (* n (+ n 1)) 2))) (sum 3)"), {
      hd: "6",
      tl: /* [] */0
    }, "rackette with define with lambda4");

CS17SetupRackette$Rackette.checkExpect(rackette("(define my-append (lambda (alon1 alon2)\n  (cond\n    ((empty? alon1) alon2)\n    ((cons? alon1) (cons (first alon1) (my-append (rest alon1) alon2))))))\n    (my-append (list 1 2 3) (list 2 3 4))"), {
      hd: "(cons 1 (cons 2 (cons 3 (cons 2 (cons 3 (cons 4 '()))))))",
      tl: /* [] */0
    }, "rackette with define with lambda5");

CS17SetupRackette$Rackette.checkExpect(rackette("(define remove-until-zero (lambda (alon)\n  (cond\n    ((empty? alon) empty)\n    ((cons? alon)\n     (if (= (first alon) 0)\n        alon\n        (remove-until-zero (rest alon)))))))\n        (remove-until-zero (list 1 0 2))"), {
      hd: "(cons 0 (cons 2 '()))",
      tl: /* [] */0
    }, "rackette with define with lambda6");

CS17SetupRackette$Rackette.checkExpect(rackette("(define sum-list (lambda (aloi)\n  (cond\n    ((empty? aloi) 0)\n    ((cons? aloi) (+ (first aloi) (sum-list (rest aloi)))))))\n    (sum-list (list 1 2 3 1 23))\n"), {
      hd: "30",
      tl: /* [] */0
    }, "rackette with define with lambda7");

CS17SetupRackette$Rackette.checkExpect(rackette("(define count-up (lambda (n k)\n  (if (= k 0)\n     empty\n     (cons n (count-up (+ n 1) (- k 1))))))\n     (count-up 34 8)"), {
      hd: "(cons 34 (cons 35 (cons 36 (cons 37 (cons 38 (cons 39 (cons 40 (cons 41 '()))))))))",
      tl: /* [] */0
    }, "rackette with define with lambda8");

CS17SetupRackette$Rackette.checkExpect(rackette("(define fact (lambda (x) \n    (if (zero? x) 1 (* x (fact (- x 1)))))) (fact 3)"), {
      hd: "6",
      tl: /* [] */0
    }, "rackette with define with lambda9");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("j");
      }), "lookup error");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("|");
      }), "invalid character identifier");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(");
      }), "wrong number of parentheses");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(+ 1 false)");
      }), "Wrong value type for +");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(* 1 2 3 3 3 3 4)");
      }), "* expects 2 arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(equal? false false false)");
      }), "equal? expects 2 arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(first empty)");
      }), "first expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("and");
      }), "invalid name");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(and false false false)");
      }), "And needs to take in two expressions");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(or false false false)");
      }), "Or needs to take in two expressions");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(if false false false false)");
      }), "If needs to take in three expressions");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cond (false 2) (true 2 3))");
      }), "invalid condData");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cond)");
      }), "Cond needs to take in at least a pair of valid condData");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(lambda (x) )");
      }), "Lambda needs to take in a list of names and an expression");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(let ((x 2 3)) 4)");
      }), "invalid let pair");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(let ((x 2 3)))");
      }), "Let needs to take in a list of pairs and an expression");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(define 3)");
      }), "invalid definition");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(and true 1)");
      }), "and expects a boolean as second argument");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(and 1 1)");
      }), "and expects a boolean as first argument");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(or false 1)");
      }), "or expects a boolean as second argument");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(or 1 1)");
      }), "or expects a boolean as first argument");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(if 1 2 3)");
      }), "if: first argument must evaluate to a boolean");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cond (false 3))");
      }), "all cases were false");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("((lambda (x) (+ x 1)) 1 2)");
      }), "formals and actuals must have the same number");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(lambda (x x) (+ 1 2))");
      }), "lambda: cannot bound a variable more than once");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(let ((x 4) (x 32)) (+ 1 x))");
      }), "let: cannot bound a variable more than once");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("f");
      }), "lookup error");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(2)");
      }), "expected a function after open parenthesis");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(define x 1) (define x 2)");
      }), "cannot redefine");

exports.initialTle = initialTle;
exports.parseExpression = parseExpression;
exports.parseDefinition = parseDefinition;
exports.parsePiece = parsePiece;
exports.parse = parse;
exports.$$eval = $$eval;
exports.addDefinition = addDefinition;
exports.stringOfValue = stringOfValue;
exports.$$process = $$process;
exports.rackette = rackette;
/*  Not a pure module */
